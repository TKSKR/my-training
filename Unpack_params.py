def print_params(a = 1, b = 'string', c = True):
    print(a, b, c)
print_params()
print_params(b = 25)
print_params(c = [1, 2, 3])
values_list = (5, 'box', False)
values_doct = {'a':10, 'b': 'text', 'c' : 1.5}
print_params(*values_list)
print_params(**values_doct)
values_list2 = (777, 'setting')
print_params(*values_list2, 42)

# Изменяемые типы данных по умолчанию: Важно помнить, что использование изменяемых типов данных (списки, словари, объекты)
# в качестве значений по умолчанию может привести к непредсказуемым результатам, если вы изменяете эти объекты внутри функции.
# Мой код работает корректно, потому что это происходит “внутри функции”, но чтобы избежать проблем,
# используйте None как значение по умолчанию и создавайте новый список внутри функции.
#
# Пример правильного использования с изменяемыми типами данных (важно):
#
def append_to_list(item, list_my=None):
    if list_my is None:
        list_my = []  # Создаем новый список внутри функции
    list_my.append(item)
    return list_my

my_list = append_to_list(1)
print(my_list) # Выведет [1]
another_list = append_to_list(2, my_list) # Передаем уже существующий список
print(another_list)  # Выведет [1, 2]
print(my_list)   # Выведет [1, 2]  (list_my был изменен только внутри append_to_list)
# Этот пример демонстрирует правильную практику: внутри функции append_to_list создается новый список,
# если он не был передан, и работа с ним не влияет на внешние переменные.


# Да, вы абсолютно правы, и я извиняюсь за неточность в предыдущем ответе. Мое утверждение о том, что list_my изменяется только внутри функции, было неверным.
#
# Правильный анализ поведения функции append_to_list:
#
# my_list = append_to_list(1):
#
# При первом вызове list_my равен None, поэтому внутри функции создается новый список [].
# В список добавляется 1, и он становится [1].
# Этот список возвращается и присваивается переменной my_list.
# Выводится [1].
# another_list = append_to_list(2, my_list):
#
# При втором вызове мы передаем существующий список my_list в функцию как list_my.
# Внутри функции list_my (который теперь указывает на тот же список, что и my_list) добавляется элемент 2, он становится [1, 2].
# Этот список (ссылка на один и тот же список!) возвращается и присваивается переменной another_list.
# Выводится [1, 2].
# print(my_list):
#
# Мы выводим my_list. Поскольку another_list и my_list на самом деле указывают на один и тот же список в памяти, то значение my_list стало равно [1, 2] из-за изменения списка внутри вызова append_to_list(2, my_list).
# Выводится [1, 2].
# Ключевая ошибка в моем предыдущем ответе:
#
# Я допустил ошибку, когда сказал, что list_my изменяется “только внутри функции”. На самом деле, когда мы передаем список в функцию и изменяем его внутри, мы изменяем сам список, на который ссылается переменная.
#
# Почему это важно:
#
# Эта особенность поведения очень важна при работе со списками и другими изменяемыми объектами в Python. Она подчеркивает, что при передаче списка в функцию передается ссылка на этот список, а не копия. Изменения, сделанные внутри функции, повлияют на исходный список вне функции, если он был передан в качестве аргумента.
#
# В качестве заключения:
#
# Если вы не хотите изменять исходный список вне функции, передавая список, вам нужно создавать его копию (например, list_my = list(list_my)).
# Если вам нужно передавать список в функцию для изменения - все работает так как вы написали.
# Большое спасибо за то, что обратили внимание на мою ошибку. Это действительно важно для понимания работы со списками и изменяемыми типами данных в Python.